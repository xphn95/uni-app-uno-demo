"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePlatformIndex = exports.resolveRootIndex = exports.genProxyCode = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const uni_cli_shared_1 = require("@dcloudio/uni-cli-shared");
const utils_1 = require("./utils");
async function genProxyCode(module, options) {
    const { name, is_uni_modules } = options;
    return `
import { extend } from '@vue/shared'
import { initUtsProxyClass, initUtsProxyFunction, initUtsPackageName, initUtsIndexClassName, initUtsClassName } from '@dcloudio/uni-app'
const name = '${name}'
const is_uni_modules = ${is_uni_modules}
const pkg = initUtsPackageName(name, is_uni_modules)
const cls = initUtsIndexClassName(name, is_uni_modules)
${genModuleCode(await parseModuleDecls(module, options))}
`;
}
exports.genProxyCode = genProxyCode;
function resolveRootIndex(module) {
    const filename = path_1.default.resolve(module, 'index.uts');
    return fs_1.default.existsSync(filename) && filename;
}
exports.resolveRootIndex = resolveRootIndex;
function resolvePlatformIndex(platform, module, options) {
    const filename = path_1.default.resolve(module, options.is_uni_modules ? 'utssdk' : '', platform, 'index.uts');
    return fs_1.default.existsSync(filename) && filename;
}
exports.resolvePlatformIndex = resolvePlatformIndex;
function genModuleCode(decls) {
    const codes = [];
    decls.forEach((decl) => {
        if (decl.type === 'Class') {
            if (decl.isDefault) {
                codes.push(`export default initUtsProxyClass(extend({ package: pkg, class: initUtsClassName(name, '${decl.cls}', is_uni_modules) }, ${JSON.stringify(decl.options)} ))`);
            }
            else {
                codes.push(`export const ${decl.cls} = initUtsProxyClass(extend({ package: pkg, class: initUtsClassName(name, '${decl.cls}', is_uni_modules) }, ${JSON.stringify(decl.options)} ))`);
            }
        }
        else if (decl.type === 'FunctionDeclaration') {
            if (decl.isDefault) {
                codes.push(`export default initUtsProxyFunction(${decl.async}, { main: true, package: pkg, class: cls, name: '${decl.method}', params: ${JSON.stringify(decl.params)}})`);
            }
            else {
                codes.push(`export const ${decl.method} = initUtsProxyFunction(${decl.async}, { main: true, package: pkg, class: cls, name: '${decl.method}', params: ${JSON.stringify(decl.params)}})`);
            }
        }
        else if (decl.type === 'VariableDeclaration') {
            codes.push(`export ${decl.kind} ${decl.declarations
                .map((d) => `${d.id.value} = ${genInitCode(d.init)}`)
                .join(', ')}`);
        }
    });
    return codes.join(`\n`);
}
async function parseModuleDecls(module, options) {
    // 优先合并 ios + android，如果没有，查找根目录 index.uts
    const iosDecls = await parseFile(resolvePlatformIndex('app-ios', module, options), options);
    const androidDecls = await parseFile(resolvePlatformIndex('app-android', module, options), options);
    // 优先使用 app-ios，因为 app-ios 平台函数类型需要正确的参数列表
    const decls = mergeDecls(androidDecls, iosDecls);
    // 如果没有平台特有，查找 root index.uts
    if (!decls.length) {
        return await parseFile(resolveRootIndex(module), options);
    }
    return decls;
}
function mergeDecls(from, to) {
    from.forEach((item) => {
        if (item.type === 'Class') {
            if (!to.find((toItem) => toItem.type === 'Class' && toItem.cls === item.cls)) {
                to.push(item);
            }
        }
        else if (item.type === 'FunctionDeclaration') {
            if (!to.find((toItem) => toItem.type === 'FunctionDeclaration' &&
                toItem.method === item.method)) {
                to.push(item);
            }
        }
        else if (item.type === 'VariableDeclaration' &&
            item.declarations.length === 1) {
            if (!to.find((toItem) => {
                if (toItem.type === 'VariableDeclaration' &&
                    toItem.declarations.length === 1) {
                    const toDecl = toItem.declarations[0].id;
                    const decl = item.declarations[0].id;
                    return (toDecl.type === 'Identifier' &&
                        decl.type === 'Identifier' &&
                        toDecl.value === decl.value);
                }
                return false;
            })) {
                to.push(item);
            }
        }
    });
    return to;
}
async function parseFile(filename, options) {
    if (filename) {
        return parseCode(fs_1.default.readFileSync(filename, 'utf8'), options.namespace);
    }
    return [];
}
async function parseCode(code, namespace) {
    // 懒加载 uts 编译器
    // eslint-disable-next-line no-restricted-globals
    const { parse } = require('@dcloudio/uts');
    const ast = await parse(code, { noColor: (0, uni_cli_shared_1.isInHBuilderX)() });
    return parseAst(ast, (0, utils_1.createResolveTypeReferenceName)(namespace, ast));
}
function parseAst({ body }, resolveTypeReferenceName) {
    const decls = [];
    body.forEach((item) => {
        if (item.type === 'ExportDeclaration') {
            const decl = item.declaration;
            switch (decl.type) {
                case 'FunctionDeclaration':
                    decls.push(genFunctionDeclaration(decl, resolveTypeReferenceName, false));
                    break;
                case 'ClassDeclaration':
                    decls.push(genClassDeclaration(decl, resolveTypeReferenceName, false));
                    break;
                case 'VariableDeclaration':
                    const varDecl = genVariableDeclaration(decl);
                    if (varDecl) {
                        decls.push(varDecl);
                    }
                    break;
            }
        }
        else if (item.type === 'ExportDefaultDeclaration') {
            const decl = item.decl;
            if (decl.type === 'ClassExpression') {
                if (decl.identifier) {
                    // export default class test{}
                    decls.push(genClassDeclaration(decl, resolveTypeReferenceName, false));
                }
            }
            else if (decl.type === 'FunctionExpression') {
                if (decl.identifier) {
                    decls.push(genFunctionDeclaration(decl, resolveTypeReferenceName, true));
                }
            }
        }
    });
    return decls;
}
function isReturnPromise(anno) {
    if (!anno) {
        return false;
    }
    const { typeAnnotation } = anno;
    return (typeAnnotation.type === 'TsTypeReference' &&
        typeAnnotation.typeName.type === 'Identifier' &&
        typeAnnotation.typeName.value === 'Promise');
}
function genProxyFunction(method, async, params, isDefault = false) {
    return { type: 'FunctionDeclaration', method, async, params, isDefault };
}
function genProxyClass(cls, options, isDefault = false) {
    return { type: 'Class', cls, options, isDefault };
}
function resolveIdentifierType(ident, resolveTypeReferenceName) {
    if (ident.typeAnnotation) {
        const { typeAnnotation } = ident.typeAnnotation;
        if (typeAnnotation.type === 'TsKeywordType') {
            return typeAnnotation.kind;
        }
        else if (typeAnnotation.type === 'TsFunctionType') {
            return 'UTSCallback';
        }
        else if (typeAnnotation.type === 'TsTypeReference' &&
            typeAnnotation.typeName.type === 'Identifier') {
            return resolveTypeReferenceName(typeAnnotation.typeName.value);
        }
    }
    return '';
}
function resolveFunctionParams(params, resolveTypeReferenceName) {
    const result = [];
    params.forEach(({ pat }) => {
        if (pat.type === 'Identifier') {
            result.push({
                name: pat.value,
                type: resolveIdentifierType(pat, resolveTypeReferenceName),
            });
        }
        else {
            result.push({ name: '', type: '' });
        }
    });
    return result;
}
function genFunctionDeclaration(decl, resolveTypeReferenceName, isDefault = false) {
    return genProxyFunction(decl.identifier.value, decl.async || isReturnPromise(decl.returnType), resolveFunctionParams(decl.params, resolveTypeReferenceName), isDefault);
}
function genClassDeclaration(decl, resolveTypeReferenceName, isDefault = false) {
    const cls = decl.identifier.value;
    const constructor = { params: [] };
    const methods = {};
    const staticMethods = {};
    const props = [];
    const staticProps = [];
    decl.body.forEach((item) => {
        if (item.type === 'Constructor') {
            constructor.params = resolveFunctionParams(item.params, resolveTypeReferenceName);
        }
        else if (item.type === 'ClassMethod') {
            if (item.key.type === 'Identifier') {
                const name = item.key.value;
                const value = {
                    async: item.function.async || isReturnPromise(item.function.returnType),
                    params: resolveFunctionParams(item.function.params, resolveTypeReferenceName),
                };
                if (item.isStatic) {
                    staticMethods[name] = value;
                }
                else {
                    methods[name] = value;
                }
            }
        }
        else if (item.type === 'ClassProperty') {
            if (item.key.type === 'Identifier') {
                if (item.isStatic) {
                    staticProps.push(item.key.value);
                }
                else {
                    props.push(item.key.value);
                }
            }
        }
    });
    return genProxyClass(cls, { constructor, methods, staticMethods, props, staticProps }, isDefault);
}
function genInitCode(expr) {
    switch (expr.type) {
        case 'BooleanLiteral':
            return expr.value + '';
        case 'NumericLiteral':
            return expr.value + '';
        case 'StringLiteral':
            return expr.value;
    }
    return '';
}
function genVariableDeclaration(decl) {
    // 目前仅支持 const 的 boolean,number,string
    const lits = ['BooleanLiteral', 'NumericLiteral', 'StringLiteral'];
    if (decl.kind === 'const' &&
        !decl.declarations.find((d) => {
            if (d.id.type !== 'Identifier') {
                return true;
            }
            if (!d.init) {
                return true;
            }
            const type = d.init.type;
            if (!lits.includes(type)) {
                return true;
            }
            return false;
        })) {
        return decl;
    }
}
