import MagicString from 'magic-string';

async function compileApplet(body, ctx, options = {}) {
  const {
    classPrefix = "uno-",
    hashFn = hash,
    layer = "applet_shortcuts"
  } = options;
  const { uno, tokens } = ctx;
  const replacements = [];
  const result = await Promise.all(body.split(/\s+/).filter(Boolean).map(async (i) => [i, i.includes("${") ? false : !!await uno.parseToken(i)]));
  const known = result.filter(([, matched]) => matched).map(([i]) => i);
  const unknown = result.filter(([, matched]) => !matched).map(([i]) => i);
  replacements.push(...unknown);
  body = known.join(" ");
  if (body) {
    const hash2 = hashFn(body);
    const className = `${classPrefix}${hash2}`;
    replacements.unshift(className);
    uno.config.shortcuts.push([className, body, { layer }]);
    tokens.add(className);
  }
  return replacements;
}
function hash(str) {
  let i;
  let l;
  let hval = 2166136261;
  for (i = 0, l = str.length; i < l; i++) {
    hval ^= str.charCodeAt(i);
    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
  }
  return `00000${(hval >>> 0).toString(36)}`.slice(-6);
}

const charReg = /[.:%!#()[\/\],]/;
const elementRE = /<\w(?=.*>)[\w:\.$-]*\s(((".*?>?.*?")|.*?)*?)\/?>/gs;
const valuedAttributeRE = /([?]|(?!\d|-{2}|-\d)[a-zA-Z0-9\u00A0-\uFFFF-_:!%-]+)(?:={?(["'])([^\2]*?)\2}?)?/g;
const stringRE = /'(.*?)'|/g;
const templateLiteralsRE = /`([\s\S]*?)`/g;
function transformerApplet(options = {}) {
  const enable = options.enable ?? true;
  const ignorePrefix = options.ignorePrefix || "applet-ignore:";
  return {
    name: "transformer-applet",
    enforce: "pre",
    async transform(s, id, ctx) {
      if (!enable)
        return;
      let code = new MagicString(s.toString());
      const elementMatches = code.original.matchAll(elementRE);
      for (const eleMatch of elementMatches) {
        const start = eleMatch.index;
        let matchStrTemp = eleMatch[0];
        const valuedAttributes = Array.from((eleMatch[1] || "").matchAll(valuedAttributeRE));
        for (const attribute of valuedAttributes) {
          const name = attribute[1];
          const content = attribute[3];
          if (!content)
            continue;
          if (["class", "className", "hover-class"].includes(name)) {
            if (name.includes(":"))
              continue;
            if (charReg.test(content)) {
              const replacements = await compileApplet(content, ctx, options);
              matchStrTemp = matchStrTemp.replace(content, replacements.join(" "));
            }
          }
        }
        if (eleMatch[0] !== matchStrTemp)
          code.overwrite(start, start + eleMatch[0].length, matchStrTemp);
      }
      code = new MagicString(code.toString());
      const stringMatches = code.original.matchAll(stringRE);
      for (const match of stringMatches) {
        if (!match[1])
          continue;
        const start = match.index;
        let content = match[1];
        if (content.startsWith(ignorePrefix)) {
          if (!/\.vue$/.test(id)) {
            content = content.substring(ignorePrefix.length).trim();
            code.overwrite(start, start + match[0].length, match[0].replace(match[1], content));
          }
        } else {
          if (/\.(png|jpg|jpeg|gif|svg)/g.test(content))
            continue;
          if (/http(s)?:\/\//g.test(content))
            continue;
          if (charReg.test(content)) {
            const replacements = await compileApplet(content, ctx, options);
            code.overwrite(start, start + match[0].length, `'${replacements.join(" ")}'`);
          }
        }
      }
      code = new MagicString(code.toString());
      const templateLiteralsMatches = code.original.matchAll(templateLiteralsRE);
      for (const match of templateLiteralsMatches) {
        const start = match.index;
        const content = match[1];
        if (charReg.test(content)) {
          const replacements = await compileApplet(content, ctx, options);
          code.overwrite(start, start + match[0].length, `\`${replacements.join(" ")}\``);
        }
      }
      s.overwrite(0, s.original.length, code.toString());
    }
  };
}

export { transformerApplet as default };
