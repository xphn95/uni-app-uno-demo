'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const MagicString = require('magic-string');
const unocss = require('unocss');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

const MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);

const strippedPrefixes = [
  "v-bind:",
  ":"
];
const splitterRE = /[\s'"`;]+/g;
const elementRE = /<\w(?=.*>)[\w:\.$-]*\s(((".*?>?.*?")|.*?)*?)\/?>/gs;
const valuedAttributeRE = /([?]|(?!\d|-{2}|-\d)[a-zA-Z0-9\u00A0-\uFFFF-_:!%-]+)(?:={?(["'])([^\2]*?)\2}?)?/g;
const defaultIgnoreAttributes = ["placeholder", "setup", "lang", "scoped"];
function transformerAttributify(options = {}) {
  const enable = options.enable ?? true;
  const ignoreAttributes = options?.ignoreAttributes ?? defaultIgnoreAttributes;
  const nonValuedAttribute = options?.nonValuedAttribute ?? true;
  const prefix = options.prefix ?? "un-";
  const prefixedOnly = options.prefixedOnly ?? false;
  const deleteClass = options.deleteClass ?? false;
  return {
    name: "transformer-attributify",
    enforce: "pre",
    async transform(s, _, { uno }) {
      if (!enable)
        return;
      const code = new MagicString__default(s.toString());
      const elementMatches = code.original.matchAll(elementRE);
      for (const eleMatch of elementMatches) {
        const start = eleMatch.index;
        let matchStrTemp = eleMatch[0];
        let existsClass = "";
        const attrSelectors = [];
        const valuedAttributes = Array.from((eleMatch[1] || "").matchAll(valuedAttributeRE));
        for (const attribute of valuedAttributes) {
          const matchStr = attribute[0];
          const name = attribute[1];
          const content = attribute[3];
          let _name = prefixedOnly ? name.replace(prefix, "") : name;
          if (!ignoreAttributes.includes(_name)) {
            for (const prefix2 of strippedPrefixes) {
              if (_name.startsWith(prefix2)) {
                _name = _name.slice(prefix2.length);
                break;
              }
            }
            if (!content) {
              if (unocss.isValidSelector(_name) && nonValuedAttribute !== false) {
                if (await uno.parseToken(_name)) {
                  attrSelectors.push(_name);
                  deleteClass && (matchStrTemp = matchStrTemp.replace(` ${_name}`, ""));
                }
              }
            } else {
              if (["class", "className"].includes(_name)) {
                if (!name.includes(":"))
                  existsClass = content;
              } else {
                const attrs = await Promise.all(content.split(splitterRE).filter(Boolean).map(async (v) => {
                  let token = v;
                  if (v === "~") {
                    token = _name;
                  } else if (v.includes(":")) {
                    const splitV = v.split(":");
                    token = `${splitV[0]}:${splitV[1]}`;
                  } else if (v.startsWith("!")) {
                    token = `!${_name}-${v.slice(1)}`;
                  } else {
                    token = `${_name}-${v}`;
                  }
                  return [token, !!await uno.parseToken(token)];
                }));
                const result = attrs.filter(([, v]) => v).map(([v]) => v);
                attrSelectors.push(...result);
                deleteClass && (matchStrTemp = matchStrTemp.replace(` ${matchStr}`, ""));
              }
            }
          }
        }
        if (attrSelectors.length) {
          if (!existsClass) {
            const sliceNum = matchStrTemp.endsWith("/>") ? -2 : -1;
            matchStrTemp = `${matchStrTemp.slice(0, sliceNum)} class="${attrSelectors.join(" ")}"${matchStrTemp.slice(sliceNum)}`;
          } else {
            matchStrTemp = matchStrTemp.replace(`"${existsClass}"`, `"${existsClass} ${attrSelectors.join(" ")}"`);
          }
          code.overwrite(start, start + eleMatch[0].length, matchStrTemp);
        }
      }
      s.overwrite(0, s.original.length, code.toString());
    }
  };
}

exports["default"] = transformerAttributify;
exports.defaultIgnoreAttributes = defaultIgnoreAttributes;
