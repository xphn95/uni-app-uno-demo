// src/core/index.ts
import { defaultRules, transformSelector } from "unplugin-transform-class/utils";
var strippedPrefixes = [
  "v-bind:",
  ":",
  "@",
  "v-on"
];
var templateRe = /<template>([\s\S]*)<\/template>/g;
var splitterRE = /[\s'"`;]+/g;
var elementRE = /<\w(?=.*>)[\w:\.$-]*\s((?:['"`].*?['"`]|.*?)*?)>/gs;
var valuedAttributeRE = /([?]|(?!\d|-{2}|-\d)[a-zA-Z0-9\u00A0-\uFFFF-_:@.!%-]+)(?:=(["'])([^\2]*?)\2)?/g;
var validateFilterRE = /(?!\d|-{2}|-\d)[a-zA-Z0-9\u00A0-\uFFFF-_:%-?]/;
function isValidSelector(selector = "") {
  return validateFilterRE.test(selector);
}
var defaultAttributes = ["bg", "flex", "grid", "border", "text", "font", "class", "className", "p", "m"];
var defaultIgnoreNonValuedAttributes = ["class"];
var extractorAttributify = (options) => {
  const attributes = (options == null ? void 0 : options.attributes) ?? defaultAttributes;
  const nonValuedAttribute = (options == null ? void 0 : options.nonValuedAttribute) ?? true;
  const ignoreNonValuedAttributes = (options == null ? void 0 : options.ignoreNonValuedAttributes) ?? defaultIgnoreNonValuedAttributes;
  const prefix = (options == null ? void 0 : options.prefix) ?? "un-";
  const prefixedOnly = (options == null ? void 0 : options.prefixedOnly) ?? false;
  const transformEscape = (options == null ? void 0 : options.transformEscape) ?? true;
  const transformRules = (options == null ? void 0 : options.transformRules) ?? defaultRules;
  const classPrefix = (options == null ? void 0 : options.classPrefix) ?? "";
  return function extract(code) {
    const result = [];
    const templateMatchs = Array.from(code.matchAll(templateRe));
    if (templateMatchs.length) {
      const templateCode = templateMatchs[0][1];
      Array.from(templateCode.matchAll(elementRE)).forEach(([elementStr, valuedAttributeStr]) => {
        const valuedAttributes = Array.from((valuedAttributeStr || "").matchAll(valuedAttributeRE));
        const option = {
          elementStr,
          staticClass: "",
          selectors: []
        };
        valuedAttributes.forEach(([sourceStr, name, _, content]) => {
          const _name = prefixedOnly ? name.replace(prefix, "") : name;
          if (!content) {
            if (name === "class")
              option.staticClass = sourceStr;
            if (isValidSelector(name) && nonValuedAttribute !== false) {
              if (!ignoreNonValuedAttributes.includes(name))
                option.selectors.push(transformEscape ? transformSelector(`${classPrefix}${name}`, transformRules) : `${classPrefix}${name}`);
            }
            return;
          }
          for (const prefix2 of strippedPrefixes) {
            if (name.startsWith(prefix2)) {
              name = name.slice(prefix2.length);
              return;
            }
          }
          if (!attributes.includes(_name))
            return;
          if (["class", "className"].includes(name)) {
            option.staticClass = sourceStr;
          } else {
            if (prefixedOnly && !name.startsWith(prefix))
              return;
            const attributifyToClass = content.split(splitterRE).filter(Boolean).map((v) => v === "~" ? `${classPrefix}${_name}` : `${classPrefix}${_name}-${transformEscape ? transformSelector(v, transformRules) : v}`).join(" ");
            option.selectors.push(attributifyToClass);
          }
        });
        result.push(option);
      });
      result.forEach(({ elementStr, staticClass, selectors }) => {
        if (selectors.length === 0)
          return;
        if (staticClass) {
          const replaceStr = elementStr.replace(staticClass, spliceStr(staticClass, -1, ` ${selectors.join(" ")}`));
          code = code.replace(elementStr, replaceStr);
        } else {
          const classStr = ` class="${selectors.join(" ")}"`;
          const insertIndex = elementStr.endsWith("/>") ? -2 : -1;
          code = code.replace(elementStr, spliceStr(elementStr, insertIndex, classStr));
        }
      });
    }
    return code;
  };
};
function spliceStr(str, start, newStr) {
  return str.slice(0, start) + newStr + str.slice(start);
}

export {
  defaultAttributes,
  defaultIgnoreNonValuedAttributes,
  extractorAttributify
};
